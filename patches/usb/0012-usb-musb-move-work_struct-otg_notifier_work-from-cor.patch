From 494bcd8594ad59d92381ef8be08e9dccf2dc9306 Mon Sep 17 00:00:00 2001
From: Kishon Vijay Abraham I <kishon@ti.com>
Date: Fri, 22 Jun 2012 17:40:51 +0530
Subject: [PATCH 12/38] usb: musb: move work_struct(otg_notifier_work) from
 core to omap glue

Commit 712d8e(fixes pm_runtime calls while atomic by using a work
queue. musb pm_runtime_get_sync call happens in interrupt context
on cable attach case. That can result in re-enabling the interrupts and
cause side affect. To avoid this deferred processing is used)

While the issue and the work queue implementation is specific to omap
(omap2430.c), the work_struct is defined as a member of struct musb
(musb_core.h). Hence moved the work_struct from musb_core to omap
glue.

Cc: Vikram Pandita <vikram.pandita@ti.com>
Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
Signed-off-by: Felipe Balbi <balbi@ti.com>
Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
---
 drivers/usb/musb/musb_core.h |    2 --
 drivers/usb/musb/omap2430.c  |   24 +++++++++++++++---------
 2 files changed, 15 insertions(+), 11 deletions(-)

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index f4a40f0..dbcdeea 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -327,7 +327,6 @@ struct musb {
 
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
-	struct work_struct	otg_notifier_work;
 	u16			hwvers;
 
 /* this hub status bit is reserved by USB 2.0 and not seen by usbcore */
@@ -373,7 +372,6 @@ struct musb {
 	u16			int_tx;
 
 	struct usb_phy		*xceiv;
-	u8			xceiv_event;
 
 	int nIrq;
 	unsigned		irq_wake:1;
diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index e279cf3..f40c805 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -41,6 +41,8 @@
 struct omap2430_glue {
 	struct device		*dev;
 	struct platform_device	*musb;
+	u8			xceiv_event;
+	struct work_struct	omap_musb_mailbox_work;
 };
 #define glue_to_musb(g)		platform_get_drvdata(g->musb)
 
@@ -226,22 +228,26 @@ static inline void omap2430_low_level_init(struct musb *musb)
 static int musb_otg_notifications(struct notifier_block *nb,
 		unsigned long event, void *unused)
 {
-	struct musb	*musb = container_of(nb, struct musb, nb);
+	struct musb		*musb = container_of(nb, struct musb, nb);
+	struct device		*dev = musb->controller;
+	struct omap2430_glue	*glue = dev_get_drvdata(dev->parent);
 
-	musb->xceiv_event = event;
-	schedule_work(&musb->otg_notifier_work);
+	glue->xceiv_event = event;
+	schedule_work(&glue->omap_musb_mailbox_work);
 
 	return NOTIFY_OK;
 }
 
-static void musb_otg_notifier_work(struct work_struct *data_notifier_work)
+static void omap_musb_mailbox_work(struct work_struct *data_notifier_work)
 {
-	struct musb *musb = container_of(data_notifier_work, struct musb, otg_notifier_work);
+	struct omap2430_glue *glue = container_of(data_notifier_work,
+		struct omap2430_glue, omap_musb_mailbox_work);
+	struct musb *musb = glue_to_musb(glue);
 	struct device *dev = musb->controller;
 	struct musb_hdrc_platform_data *pdata = dev->platform_data;
 	struct omap_musb_board_data *data = pdata->board_data;
 
-	switch (musb->xceiv_event) {
+	switch (glue->xceiv_event) {
 	case USB_EVENT_ID:
 		dev_dbg(musb->controller, "ID GND\n");
 
@@ -298,8 +304,6 @@ static int omap2430_musb_init(struct musb *musb)
 		return -ENODEV;
 	}
 
-	INIT_WORK(&musb->otg_notifier_work, musb_otg_notifier_work);
-
 	status = pm_runtime_get_sync(dev);
 	if (status < 0) {
 		dev_err(dev, "pm_runtime_get_sync FAILED %d\n", status);
@@ -388,7 +392,6 @@ static void omap2430_musb_disable(struct musb *musb)
 static int omap2430_musb_exit(struct musb *musb)
 {
 	del_timer_sync(&musb_idle_timer);
-	cancel_work_sync(&musb->otg_notifier_work);
 
 	omap2430_low_level_exit(musb);
 	usb_put_phy(musb->xceiv);
@@ -441,6 +444,8 @@ static int __devinit omap2430_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, glue);
 
+	INIT_WORK(&glue->omap_musb_mailbox_work, omap_musb_mailbox_work);
+
 	ret = platform_device_add_resources(musb, pdev->resource,
 			pdev->num_resources);
 	if (ret) {
@@ -478,6 +483,7 @@ static int __devexit omap2430_remove(struct platform_device *pdev)
 {
 	struct omap2430_glue		*glue = platform_get_drvdata(pdev);
 
+	cancel_work_sync(&glue->omap_musb_mailbox_work);
 	platform_device_del(glue->musb);
 	platform_device_put(glue->musb);
 	kfree(glue);
-- 
1.7.7.6

