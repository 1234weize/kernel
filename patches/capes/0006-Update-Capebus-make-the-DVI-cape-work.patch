From e276c9c4a90185b2df8481e350c7aa3aa49d3a2a Mon Sep 17 00:00:00 2001
From: Pantelis Antoniou <panto@antoniou-consulting.com>
Date: Sat, 29 Sep 2012 16:38:29 +0300
Subject: [PATCH 6/8] Update Capebus & make the DVI cape work!

---
 arch/arm/boot/dts/am335x-bone.dts |   82 +++++++++++-
 drivers/capebus/bone-dvi-cape.c   |  268 +++++++++++++++++++++++++++++++++++--
 drivers/capebus/capebus-driver.c  |   82 ++++++++++--
 drivers/capebus/capebus.h         |    8 +-
 4 files changed, 411 insertions(+), 29 deletions(-)

diff --git a/arch/arm/boot/dts/am335x-bone.dts b/arch/arm/boot/dts/am335x-bone.dts
index 23d5496..3d79c9d 100644
--- a/arch/arm/boot/dts/am335x-bone.dts
+++ b/arch/arm/boot/dts/am335x-bone.dts
@@ -55,12 +55,66 @@
 			>;
 		};
 
-		bone_dvi_cape_pins: pinmux_bone_dvi_cape_pins {
+		bone_dvi_cape_led_pins: pinmux_bone_dvi_cape_led_pins {
 			pinctrl-single,pins = <
 				0x48 0x07	/* gpmc_a2.gpio1_18, OUTPUT | MODE7 */
 				0x4c 0x07	/* gpmc_a3.gpio1_19, OUTPUT | MODE7 */
 			>;
 		};
+
+		bone_dvi_cape_dvi_00A0_pins: pinmux_bone_dvi_cape_dvi_00A0_pins {
+			pinctrl-single,pins = <
+				0x1c 0x07	/* gpmc_ad7.gpio1_7, OUTPUT | MODE7 - DVIPDn */
+
+				0xa0 0x08	/* lcd_data0.lcd_data0, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xa4 0x08	/* lcd_data1.lcd_data1, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xa8 0x08	/* lcd_data2.lcd_data2, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xac 0x08	/* lcd_data3.lcd_data3, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xb0 0x08	/* lcd_data4.lcd_data4, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xb4 0x08	/* lcd_data5.lcd_data5, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xb8 0x08	/* lcd_data6.lcd_data6, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xbc 0x08	/* lcd_data7.lcd_data7, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xc0 0x08	/* lcd_data8.lcd_data8, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xc4 0x08	/* lcd_data9.lcd_data9, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xc8 0x08	/* lcd_data10.lcd_data10, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xcc 0x08	/* lcd_data11.lcd_data11, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xd0 0x08	/* lcd_data12.lcd_data12, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xd4 0x08	/* lcd_data13.lcd_data13, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xd8 0x08	/* lcd_data14.lcd_data14, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xdc 0x08	/* lcd_data15.lcd_data15, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xe0 0x00	/* lcd_vsync.lcd_vsync, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+				0xe4 0x00	/* lcd_hsync.lcd_hsync, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+				0xe8 0x00	/* lcd_pclk.lcd_pclk, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+				0xec 0x00	/* lcd_ac_bias_en.lcd_ac_bias_en, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+			>;
+		};
+
+		bone_dvi_cape_dvi_00A1_pins: pinmux_bone_dvi_cape_dvi_00A1_pins {
+			pinctrl-single,pins = <
+				0x84 0x07	/* gpmc_csn2.gpio1_31, OUTPUT | MODE7 - DVIPDn */
+
+				0xa0 0x08	/* lcd_data0.lcd_data0, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xa4 0x08	/* lcd_data1.lcd_data1, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xa8 0x08	/* lcd_data2.lcd_data2, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xac 0x08	/* lcd_data3.lcd_data3, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xb0 0x08	/* lcd_data4.lcd_data4, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xb4 0x08	/* lcd_data5.lcd_data5, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xb8 0x08	/* lcd_data6.lcd_data6, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xbc 0x08	/* lcd_data7.lcd_data7, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xc0 0x08	/* lcd_data8.lcd_data8, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xc4 0x08	/* lcd_data9.lcd_data9, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xc8 0x08	/* lcd_data10.lcd_data10, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xcc 0x08	/* lcd_data11.lcd_data11, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xd0 0x08	/* lcd_data12.lcd_data12, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xd4 0x08	/* lcd_data13.lcd_data13, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xd8 0x08	/* lcd_data14.lcd_data14, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xdc 0x08	/* lcd_data15.lcd_data15, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xe0 0x00	/* lcd_vsync.lcd_vsync, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+				0xe4 0x00	/* lcd_hsync.lcd_hsync, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+				0xe8 0x00	/* lcd_pclk.lcd_pclk, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+				0xec 0x00	/* lcd_ac_bias_en.lcd_ac_bias_en, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+			>;
+		};
 	};
 
 	ocp {
@@ -259,10 +313,34 @@
 &bone_dvi_cape {
 	board-name = "BeagleBone DVI-D CAPE";
 
+	/* hacky, since this is not a proper DT platform device */
+	/* but until we have DT bindings... */ 
+	version@00A0 {
+		version = "00A0";
+		dvi {
+			compatible = "da8xx-dt";
+			pinctrl-names = "default";
+			pinctrl-0 = <&bone_dvi_cape_dvi_00A0_pins>;
+			powerdn-gpio = <&gpio1 7 0>;
+			ti,hwmods = "lcdc";
+		};
+	};
+
+	version@00A1 {
+		version = "00A1";
+		dvi {
+			compatible = "da8xx-dt";
+			pinctrl-names = "default";
+			pinctrl-0 = <&bone_dvi_cape_dvi_00A1_pins>;
+			powerdn-gpio = <&gpio1 31 0>;
+			ti,hwmods = "lcdc";
+		};
+	};
+
 	gpio-leds {
 		compatible = "gpio-leds";
 		pinctrl-names = "default";
-		pinctrl-0 = <&bone_dvi_cape_pins>;
+		pinctrl-0 = <&bone_dvi_cape_led_pins>;
 
 		dvi-led0 {
 			label = "dvi:green:usr0";
diff --git a/drivers/capebus/bone-dvi-cape.c b/drivers/capebus/bone-dvi-cape.c
index c81b8e2..c4ba4cf 100644
--- a/drivers/capebus/bone-dvi-cape.c
+++ b/drivers/capebus/bone-dvi-cape.c
@@ -11,14 +11,42 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/bitops.h>
+#include <linux/err.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <video/da8xx-fb.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/atomic.h>
+#include <linux/clk.h>
+#include <asm/barrier.h>
+#include <plat/clock.h>
+#include <plat/omap_device.h>
+#include <linux/clkdev.h>
 
 #include "capebus-bone.h"
 
 /* fwd decl. */
 extern struct cape_driver bonedvi_driver;
 
+struct da8xx_priv {
+	int power_dn_gpio;
+	struct da8xx_lcdc_platform_data dvi_pdata;
+	struct lcd_ctrl_config dvi_cfg;
+	struct display_panel dvi_panel;
+	struct platform_device *lcdc_pdev;
+	struct omap_hwmod *lcdc_oh;
+	struct resource lcdc_res[1];
+};
+
+struct bone_dvi_info {
+	struct cape_dev *dev;
+	struct platform_device *leds_pdev;
+	struct platform_device *da8xx_pdev;
+};
+
 static const struct of_device_id bonedvi_of_match[] = {
 	{
 		.compatible = "bone-dvi-cape",
@@ -27,28 +55,196 @@ static const struct of_device_id bonedvi_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, bonedvi_of_match);
 
-struct bone_dvi_info {
-	struct cape_dev *dev;
-	struct platform_device *leds_pdev;
+static const struct of_device_id of_da8xx_dt_match[] = {
+	{ .compatible = "da8xx-dt", },
+	{},
 };
 
+static int __devinit da8xx_dt_probe(struct platform_device *pdev)
+{
+	struct da8xx_priv *priv;
+	struct clk *disp_pll, *lcdc_clk;
+	struct clk_lookup *l;
+	struct pinctrl *pinctrl;
+	int ret = -EINVAL;
+
+	dev_info(&pdev->dev, "In probe!\n");
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (priv == NULL) {
+		dev_err(&pdev->dev, "Failed to allocate priv\n");
+		return -ENOMEM;
+	}
+
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl))
+		dev_warn(&pdev->dev,
+			"pins are not configured from the driver\n");
+
+	dev_info(&pdev->dev, "DVI pins configured!\n");
+
+	/* conf_disp_pll(560000000); */
+	disp_pll = clk_get(NULL, "dpll_disp_ck");
+	if (IS_ERR(disp_pll)) {
+		dev_err(&pdev->dev, "Cannot clk_get disp_pll\n");
+		return PTR_ERR(disp_pll);
+	}
+	ret = clk_set_rate(disp_pll, 560000000);
+	clk_put(disp_pll);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Failed to set disp_pll\n");
+		return ret;
+	}
+	dev_info(&pdev->dev, "disp_pll set OK\n");
+
+	ret = of_get_named_gpio_flags(pdev->dev.of_node, "powerdn-gpio", 0, NULL);
+	if (IS_ERR_VALUE(ret)) {
+		dev_err(&pdev->dev, "Failed to get power down GPIO\n");
+		return ret;
+	}
+	priv->power_dn_gpio = ret;
+
+	dev_info(&pdev->dev, "Power down GPIO # is %d\n", priv->power_dn_gpio);
+
+	ret = gpio_request(priv->power_dn_gpio, "bone-dvi-cape:DVI_PDN");
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Failed to gpio_request\n");
+		return ret;
+	}
+
+	ret = gpio_direction_output(priv->power_dn_gpio, 1);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Failed to set powerdn to 1\n");
+		return ret;
+	}
+
+	dev_info(&pdev->dev, "DVI Power down is set to 1\n");
+
+	/* display_panel */
+	priv->dvi_panel.panel_type	= QVGA;
+	priv->dvi_panel.max_bpp		= 16;
+	priv->dvi_panel.min_bpp		= 16;
+	priv->dvi_panel.panel_shade	= COLOR_ACTIVE;
+
+	/* lcd_ctrl_config */
+	priv->dvi_cfg.p_disp_panel	= &priv->dvi_panel;
+	priv->dvi_cfg.ac_bias		= 255;
+	priv->dvi_cfg.ac_bias_intrpt	= 0;
+	priv->dvi_cfg.dma_burst_sz	= 16;
+	priv->dvi_cfg.bpp		= 16;
+	priv->dvi_cfg.fdd		= 0x80;
+	priv->dvi_cfg.tft_alt_mode	= 0;
+	priv->dvi_cfg.stn_565_mode	= 0;
+	priv->dvi_cfg.mono_8bit_mode	= 0;
+	priv->dvi_cfg.invert_line_clock	= 1;
+	priv->dvi_cfg.invert_frm_clock	= 1;
+	priv->dvi_cfg.sync_edge		= 0;
+	priv->dvi_cfg.sync_ctrl		= 1;
+	priv->dvi_cfg.raster_order	= 0;
+
+	/* da8xx_lcdc_platform_data */
+	strcpy(priv->dvi_pdata.manu_name, "BBToys");
+	priv->dvi_pdata.controller_data	= &priv->dvi_cfg;
+	strcpy(priv->dvi_pdata.type, "1024x768@60");
+
+	dev_info(&pdev->dev, "Registering lcdc\n");
+
+	priv->lcdc_oh = omap_hwmod_lookup("lcdc");
+	if (priv->lcdc_oh == NULL) {
+		dev_err(&pdev->dev, "Failed to lookup omap_hwmod lcdc\n");
+		return -ENODEV;
+	}
+
+	priv->lcdc_pdev = omap_device_build("da8xx_lcdc", 0, priv->lcdc_oh,
+			&priv->dvi_pdata, sizeof(struct da8xx_lcdc_platform_data),
+			NULL, 0, 0);
+	if (priv->lcdc_pdev == NULL) {
+		dev_err(&pdev->dev, "Failed to build LCDC device\n");
+		return -ENODEV;
+	}
+
+#if 0
+	priv->lcdc_pdev->dev.parent = &pdev->dev;
+	priv->lcdc_pdev->dev.platform_data = &priv->dvi_pdata;
+	
+	priv->lcdc_res[0].start = 0x4830E000;
+	priv->lcdc_res[0].end = 0x4830E000 + SZ_8K - 1;
+	priv->lcdc_res[0].flags = IORESOURCE_MEM;
+
+	lcdc_clk = omap_clk_get_by_name("lcd_gclk");
+	if (IS_ERR(lcdc_clk)) {
+		dev_err(&pdev->dev, "Failed to get lcdc_fck");
+		return PTR_ERR(lcdc_clk);
+	}
+
+#if 0
+	l = clkdev_alloc(lcdc_clk, "fck", dev_name(&priv->lcdc_pdev->dev));
+	if (!l) {
+		dev_err(&pdev->dev, "Failed to clkdev_alloc");
+		return -ENODEV;
+	}
+
+	clkdev_add(l);
+#endif
+
+	priv->lcdc_pdev->resource = priv->lcdc_res;
+	priv->lcdc_pdev->num_resources = ARRAY_SIZE(priv->lcdc_res);
+
+	dev_info(&pdev->dev, "Adding lcdc\n");
+
+	ret = platform_device_add(priv->lcdc_pdev);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Failed to add LCDC platform device\n");
+		return -ENODEV;
+	}
+#endif
+
+	dev_info(&pdev->dev, "ALL OK\n");
+
+	platform_set_drvdata(pdev, priv);
+
+	return 0;
+}
+
+static int __devexit da8xx_dt_remove(struct platform_device *pdev)
+{
+	return -EINVAL;	/* not supporting removal yet */
+}
+
+static struct platform_driver da8xx_dt_driver = {
+	.probe		= da8xx_dt_probe,
+	.remove		= __devexit_p(da8xx_dt_remove),
+	.driver		= {
+		.name	= "da8xx-dt",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_da8xx_dt_match,
+	},
+};
+
+static atomic_t da8xx_dt_driver_used = ATOMIC_INIT(0);
+
 static int bonedvi_probe(struct cape_dev *dev, const struct cape_device_id *id)
 {
 	static const struct of_device_id gpio_leds_of_match[] = {
-		{ .compatible = "gpio-leds", },
-		{ },
+		{ .compatible = "gpio-leds", }, { },
 	};
-	char rname[33];
+	static const struct of_device_id da8xx_dt_of_match[] = {
+		{ .compatible = "da8xx-dt", }, { },
+	};
+	char boardbuf[33];
+	char versionbuf[5];
 	const char *board_name;
+	const char *version;
 	const struct of_device_id *match;
 	struct bone_dvi_info *info;
+	int err;
 
 	/* only beaglebone is supported */
 	if (strcmp(id->name, "beaglebone") != 0)
 		return -ENODEV;
 
 	/* get the board name */
-	board_name = bone_capebus_id_get_field(id, BONE_CAPEBUS_BOARD_NAME, rname, sizeof(rname));
+	board_name = bone_capebus_id_get_field(id, BONE_CAPEBUS_BOARD_NAME, boardbuf, sizeof(boardbuf));
 	if (board_name == NULL)
 		return -ENODEV;
 
@@ -57,22 +253,70 @@ static int bonedvi_probe(struct cape_dev *dev, const struct cape_device_id *id)
 	if (match == NULL)
 		return -ENODEV;
 
-	dev_info(&dev->dev, "%s: initialized - '%s'\n", board_name, match->compatible);
+	/* get the board version */
+	version = bone_capebus_id_get_field(id, BONE_CAPEBUS_VERSION, versionbuf, sizeof(versionbuf));
+	if (version == NULL)
+		return -ENODEV;
+
+	smp_mb();
+	if (atomic_inc_return(&da8xx_dt_driver_used) == 1) {
+		smp_mb();
+		err = platform_driver_register(&da8xx_dt_driver);
+		if (err != 0) {
+			dev_err(&dev->dev, "Failed to register da8xx_dt platform driver\n");
+			return -ENODEV;
+		}
+	}
+	smp_mb();
+
+	dev_info(&dev->dev, "%s: V=%s initialized - '%s'\n", board_name, version, match->compatible);
 
 	dev->drv_priv = devm_kzalloc(&dev->dev, sizeof(*info), GFP_KERNEL);
 	if (dev->drv_priv == NULL) {
 		dev_err(&dev->dev, "Failed to allocate info\n");
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto err_no_mem;
 	}
 	info = dev->drv_priv;
 
-	info->leds_pdev = capebus_of_platform_compatible_device_create(dev, gpio_leds_of_match, "dvi-cape-leds");
-	if (info->leds_pdev == NULL) {
+	info->leds_pdev = capebus_of_platform_compatible_device_create(dev,
+			gpio_leds_of_match, "dvi-cape-leds",
+			"version", version);
+	if (IS_ERR(info->leds_pdev)) {
+		info->leds_pdev = NULL;
 		dev_err(&dev->dev, "Failed to create platform led platform device\n");
-		return -ENODEV;
+		err = -ENODEV;
+		goto err_no_leds_pdev;
 	}
 
+	dev_info(&dev->dev, "LED pdev created OK\n");
+
+	info->da8xx_pdev = capebus_of_platform_compatible_device_create(dev,
+			da8xx_dt_of_match, "dvi-cape-da8xx",
+			"version", version);
+	if (IS_ERR(info->da8xx_pdev)) {
+		info->da8xx_pdev = NULL;
+		dev_err(&dev->dev, "Failed to create platform led platform device\n");
+		err = -ENODEV;
+		goto err_no_da8xx_fb;
+	}
+
+	dev_info(&dev->dev, "da8xx-dt pdev created OK\n");
+
 	return 0;
+
+err_no_da8xx_fb:
+	platform_device_unregister(info->leds_pdev);
+err_no_leds_pdev:
+	devm_kfree(&dev->dev, info);
+err_no_mem:
+	smp_mb();
+	if (atomic_dec_return(&da8xx_dt_driver_used) == 0) {
+		smp_mb();
+		platform_driver_unregister(&da8xx_dt_driver);
+	}
+	smp_mb();
+	return err;
 }
 
 static void bonedvi_remove(struct cape_dev *dev)
diff --git a/drivers/capebus/capebus-driver.c b/drivers/capebus/capebus-driver.c
index b1f0830..84c93e0 100644
--- a/drivers/capebus/capebus-driver.c
+++ b/drivers/capebus/capebus-driver.c
@@ -29,6 +29,10 @@
 #include <linux/pm_runtime.h>
 #include <linux/suspend.h>
 
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+
 #include "capebus.h"
 
 /**
@@ -345,30 +349,80 @@ next_node:
 }
 EXPORT_SYMBOL(capebus_of_match_device);
 
-struct platform_device *
-capebus_of_platform_compatible_device_create(struct cape_dev *dev,
+struct device_node *
+capebus_of_compatible_device_property_match(struct cape_dev *dev,
 		const struct of_device_id *matches,
-		const char *pdev_name)
+		const char *prop, const char *prop_value)
 {
 	const struct of_device_id *match;
-	struct device_node *node, *node2;
-	struct platform_device *pdev;
+	struct device_node *node, *node2, *node3, *node4;
+	const char* cp;
+	int cplen, l;
 
-	node2 = NULL;
-	match = NULL;
-	while ((node = of_get_next_child(dev->dev.of_node, node2)) != NULL) { 
+	if (prop == NULL || prop_value == NULL)
+		goto try_non_property;
+
+	/* at first try secondary match */
+	for (node2 = NULL;
+		(node = of_get_next_child(dev->dev.of_node, node2)) != NULL;
+		node2 = node) { 
+
+		cp = of_get_property(node, prop, &cplen);
+		if (cp == NULL)
+			continue;
+
+		while (cplen > 0) {
+			if (of_compat_cmp(cp, prop_value, strlen(prop_value)) == 0)
+				break;
+			l = strlen(cp) + 1;
+			cp += l;
+			cplen -= l;
+		}
+
+		/* not matched */
+		if (cplen <= 0)
+			continue;
+
+		/* now iterate in the children nodes */
+		for (node4 = NULL;
+			(node3 = of_get_next_child(node, node4)) != NULL;
+			node4 = node3) { 
+
+			match = of_match_node(matches, node3);
+			if (match) {
+				/* release reference to parent, keep this one */
+				of_node_put(node);
+				return node3;
+			}
+		}
+	}
+
+try_non_property:
+	for (node2 = NULL;
+		(node = of_get_next_child(dev->dev.of_node, node2)) != NULL;
+		node2 = node) { 
 
 		match = of_match_node(matches, node);
 		if (match)
-			break;
-
-		node2 = node;
+			return node;
 	}
 
-	if (node == NULL) {
-		dev_err(&dev->dev, "failed to find compatible node\n");
+	return NULL;
+}
+EXPORT_SYMBOL(capebus_of_compatible_device_property_match);
+
+struct platform_device *
+capebus_of_platform_compatible_device_create(struct cape_dev *dev,
+		const struct of_device_id *matches,
+		const char *pdev_name,
+		const char *prop, const char *prop_value)
+{
+	struct device_node *node;
+	struct platform_device *pdev;
+
+	node = capebus_of_compatible_device_property_match(dev, matches, prop, prop_value);
+	if (node == NULL)
 		return ERR_PTR(-ENODEV);
-	}
 
 	pdev = of_platform_device_create(node, pdev_name, dev->bus->dev.parent);
 
diff --git a/drivers/capebus/capebus.h b/drivers/capebus/capebus.h
index 24d9250..e1f1ade 100644
--- a/drivers/capebus/capebus.h
+++ b/drivers/capebus/capebus.h
@@ -184,9 +184,15 @@ const struct of_device_id *
 capebus_of_match_device(const struct of_device_id *matches, struct cape_dev *cdev,
 		const char *property, const char *value);
 
+struct device_node *
+capebus_of_compatible_device_property_match(struct cape_dev *dev,
+		const struct of_device_id *matches,
+		const char *prop, const char *prop_value);
+
 struct platform_device *
 capebus_of_platform_compatible_device_create(struct cape_dev *dev,
 		const struct of_device_id *matches,
-		const char *pdev_name);
+		const char *pdev_name,
+		const char *prop, const char *prop_value);
 
 #endif
-- 
1.7.7.6

