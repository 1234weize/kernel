From 36bc5c6f43186e755ea084847b8d668daed931b7 Mon Sep 17 00:00:00 2001
From: Pantelis Antoniou <panto@antoniou-consulting.com>
Date: Wed, 17 Oct 2012 20:19:41 +0300
Subject: [PATCH 16/19] bone-lcd3: Add support for the LCD3 cape

Everything works but the touchscreen.

Also using a backlight value other than 100 kills the ethernet.
---
 arch/arm/boot/dts/am335x-bone.dts      |  134 ++++++++++++
 drivers/capebus/capes/Kconfig          |    7 +
 drivers/capebus/capes/Makefile         |    1 +
 drivers/capebus/capes/bone-lcd3-cape.c |  363 ++++++++++++++++++++++++++++++++
 4 files changed, 505 insertions(+), 0 deletions(-)
 create mode 100644 drivers/capebus/capes/bone-lcd3-cape.c

diff --git a/arch/arm/boot/dts/am335x-bone.dts b/arch/arm/boot/dts/am335x-bone.dts
index f4e268a..632ee8a 100644
--- a/arch/arm/boot/dts/am335x-bone.dts
+++ b/arch/arm/boot/dts/am335x-bone.dts
@@ -134,6 +134,47 @@
 				0x19c 0x37 	/* mcasp0_ahclkr.gpio3_17, OMAP_MUX_MODE4 | INPUT_PULLUP */
 			>;
 		};
+
+		bone_lcd3_cape_led_00A0_pins: pinmux_bone_lcd3_cape_led_00A0_pins {
+			pinctrl-single,pins = <
+				0x48 0x07	/* gpmc_a2.gpio1_18, OUTPUT | MODE7 */
+			>;
+		};
+
+		bone_lcd3_cape_lcd_pins: pinmux_bone_lcd3_cape_lcd_pins {
+			pinctrl-single,pins = <
+				0xa0 0x08	/* lcd_data0.lcd_data0, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xa4 0x08	/* lcd_data1.lcd_data1, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xa8 0x08	/* lcd_data2.lcd_data2, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xac 0x08	/* lcd_data3.lcd_data3, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xb0 0x08	/* lcd_data4.lcd_data4, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xb4 0x08	/* lcd_data5.lcd_data5, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xb8 0x08	/* lcd_data6.lcd_data6, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xbc 0x08	/* lcd_data7.lcd_data7, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xc0 0x08	/* lcd_data8.lcd_data8, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xc4 0x08	/* lcd_data9.lcd_data9, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xc8 0x08	/* lcd_data10.lcd_data10, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xcc 0x08	/* lcd_data11.lcd_data11, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xd0 0x08	/* lcd_data12.lcd_data12, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xd4 0x08	/* lcd_data13.lcd_data13, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xd8 0x08	/* lcd_data14.lcd_data14, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xdc 0x08	/* lcd_data15.lcd_data15, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT | AM33XX_PULL_DISA */
+				0xe0 0x00	/* lcd_vsync.lcd_vsync, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+				0xe4 0x00	/* lcd_hsync.lcd_hsync, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+				0xe8 0x00	/* lcd_pclk.lcd_pclk, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+				0xec 0x00	/* lcd_ac_bias_en.lcd_ac_bias_en, OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT */
+			>;
+		};
+
+		bone_lcd3_cape_keys_00A0_pins: pinmux_bone_lcd3_cape_keys_00A0_pins {
+			pinctrl-single,pins = <
+				0x040 0x2f	/* gpmc_a0.gpio1_16, INPUT | PULLDIS | MODE7 */
+				0x044 0x2f	/* gpmc_a1.gpio1_17, INPUT | PULLDIS | MODE7 */
+				0x1a4 0x2f	/* mcasp0_fsr.gpio3_19, INPUT | PULLDIS | MODE7 */
+				0x078 0x2f	/* gpmc_ben1.gpio1_28, INPUT | PULLDIS | MODE7 */
+				0x164 0x2f	/* ecap0_in_pwm0_out.gpio0_7, INPUT | PULLDIS | MODE7 */
+			>;
+		};
 	};
 
 	ocp {
@@ -195,6 +236,10 @@
 				compatible = "bone-geiger-cape";
 			};
 
+			bone_lcd3_cape: cape@2 {
+				compatible = "bone-lcd3-cape";
+			};
+
 			/* overrides; no EEPROM (prototyping) */
 //			override@3 {
 //				compatible = "bone-capebus-slot-override";
@@ -295,6 +340,7 @@
 			regulator-always-on;
 		};
 	};
+
 };
 
 &mmc1 {
@@ -422,3 +468,91 @@
 		};
 	};
 };
+
+&bone_lcd3_cape {
+	board-name = "BeagleBone LCD3 CAPE";
+
+	/* hacky, since this is not a proper DT platform device */
+	/* but until we have DT bindings... */
+	lcd3 {
+		compatible = "da8xx-dt";
+		pinctrl-names = "default";
+		pinctrl-0 = <&bone_lcd3_cape_lcd_pins>;
+		ti,hwmods = "lcdc";
+	};
+
+	version@00A0 {
+		version = "00A0";
+
+		backlight {
+			compatible = "tps65217-backlight";
+			isel = <1>;
+			fdim = <200>;
+
+			tps = <&tps>;	/* link to the tps */
+			brightness = <100>;
+		};
+
+		gpio-leds {
+			compatible = "gpio-leds";
+			pinctrl-names = "default";
+			pinctrl-0 = <&bone_lcd3_cape_led_00A0_pins>;
+
+			lcd3-led0 {
+				label = "lcd3:green:usr0";
+				gpios = <&gpio2 18 0>;
+				linux,default-trigger = "heartbeat";
+				default-state = "off";
+			};
+		};
+
+		gpio_keys {
+			compatible = "gpio-keys";
+			pinctrl-names = "default";
+			pinctrl-0 = <&bone_lcd3_cape_keys_00A0_pins>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			button@1 {
+				debounce_interval = <50>;
+				linux,code = <105>;
+				label = "left";
+				gpios = <&gpio2 16 0x0>;
+				gpio-key,wakeup;
+				autorepeat;
+			};
+			button@2 {
+				debounce_interval = <50>;
+				linux,code = <106>;
+				label = "right";
+				gpios = <&gpio2 17 0x0>;
+				gpio-key,wakeup;
+				autorepeat;
+			};
+			button@3 {
+				debounce_interval = <50>;
+				linux,code = <103>;
+				label = "up";
+				gpios = <&gpio4 19 0x0>;
+				gpio-key,wakeup;
+				autorepeat;
+			};
+			button@4 {
+				debounce_interval = <50>;
+				linux,code = <108>;
+				label = "down";
+				gpios = <&gpio2 28 0x0>;
+				gpio-key,wakeup;
+				autorepeat;
+			};
+			button@5 {
+				debounce_interval = <50>;
+				linux,code = <28>;
+				label = "enter";
+				gpios = <&gpio1 7 0x0>;
+				gpio-key,wakeup;
+			};
+		};
+	};
+};
diff --git a/drivers/capebus/capes/Kconfig b/drivers/capebus/capes/Kconfig
index fcb9f0f..46a162f 100644
--- a/drivers/capebus/capes/Kconfig
+++ b/drivers/capebus/capes/Kconfig
@@ -11,3 +11,10 @@ config CAPEBUS_BONE_GEIGER
 	default n
 	help
 	  "Select this to enable a driver for the geiger cape"
+
+config CAPEBUS_BONE_LCD3
+	tristate "Beaglebone LCD3 cape driver"
+	depends on CAPEBUS_BONE_CONTROLLER
+	default n
+	help
+	  "Select this to enable a driver for the LCD3 cape"
diff --git a/drivers/capebus/capes/Makefile b/drivers/capebus/capes/Makefile
index c2fbc16..9bd73bf 100644
--- a/drivers/capebus/capes/Makefile
+++ b/drivers/capebus/capes/Makefile
@@ -1,2 +1,3 @@
 obj-$(CONFIG_CAPEBUS_BONE_DVI)		+= bone-dvi-cape.o
 obj-$(CONFIG_CAPEBUS_BONE_GEIGER)	+= bone-geiger-cape.o
+obj-$(CONFIG_CAPEBUS_BONE_LCD3)		+= bone-lcd3-cape.o
diff --git a/drivers/capebus/capes/bone-lcd3-cape.c b/drivers/capebus/capes/bone-lcd3-cape.c
new file mode 100644
index 0000000..875a722
--- /dev/null
+++ b/drivers/capebus/capes/bone-lcd3-cape.c
@@ -0,0 +1,363 @@
+/*
+ * Driver for beaglebone LCD3 cape
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <video/da8xx-fb.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/atomic.h>
+#include <linux/clk.h>
+#include <asm/barrier.h>
+#include <plat/clock.h>
+#include <plat/omap_device.h>
+#include <linux/clkdev.h>
+#include <linux/input/ti_tsc.h>
+#include <linux/platform_data/ti_adc.h>
+#include <linux/mfd/ti_tscadc.h>
+
+#include <linux/capebus/capebus-bone.h>
+
+/* fwd decl. */
+extern struct cape_driver bonelcd3_driver;
+
+struct da8xx_priv {
+	struct da8xx_lcdc_platform_data lcd3_pdata;
+	struct lcd_ctrl_config lcd3_cfg;
+	struct display_panel lcd3_panel;
+	struct platform_device *lcdc_pdev;
+	struct omap_hwmod *lcdc_oh;
+	struct resource lcdc_res[1];
+};
+
+struct bone_lcd3_info {
+	struct cape_dev *dev;
+	struct platform_device *leds_pdev;
+	struct platform_device *da8xx_pdev;
+	struct platform_device *tps_bl_pdev;
+	struct platform_device *pwm_bl_pdev;
+	struct platform_device *keys_pdev;
+	struct omap_hwmod *tsc_oh;
+	struct tsc_data tsc_data;
+	struct adc_data adc_data;
+	struct mfd_tscadc_board tscadc_data;
+	struct platform_device *tscadc_pdev;
+};
+
+static const struct of_device_id bonelcd3_of_match[] = {
+	{
+		.compatible = "bone-lcd3-cape",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bonelcd3_of_match);
+
+static const struct of_device_id of_da8xx_dt_match[] = {
+	{ .compatible = "da8xx-dt", },
+	{},
+};
+
+static int __devinit da8xx_dt_probe(struct platform_device *pdev)
+{
+	struct da8xx_priv *priv;
+	struct clk *disp_pll;
+	struct pinctrl *pinctrl;
+	int ret = -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (priv == NULL) {
+		dev_err(&pdev->dev, "Failed to allocate priv\n");
+		return -ENOMEM;
+	}
+
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl))
+		dev_warn(&pdev->dev,
+			"pins are not configured from the driver\n");
+
+	/* conf_disp_pll(16000000); */
+	disp_pll = clk_get(NULL, "dpll_disp_ck");
+	if (IS_ERR(disp_pll)) {
+		dev_err(&pdev->dev, "Cannot clk_get disp_pll\n");
+		return PTR_ERR(disp_pll);
+	}
+	ret = clk_set_rate(disp_pll, 16000000);
+	clk_put(disp_pll);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Failed to set disp_pll\n");
+		return ret;
+	}
+
+	/* display_panel */
+	priv->lcd3_panel.panel_type	= QVGA;
+	priv->lcd3_panel.max_bpp	= 16;
+	priv->lcd3_panel.min_bpp	= 16;
+	priv->lcd3_panel.panel_shade	= COLOR_ACTIVE;
+
+	/* lcd_ctrl_config */
+	priv->lcd3_cfg.p_disp_panel	= &priv->lcd3_panel;
+	priv->lcd3_cfg.ac_bias		= 255;
+	priv->lcd3_cfg.ac_bias_intrpt	= 0;
+	priv->lcd3_cfg.dma_burst_sz	= 16;
+	priv->lcd3_cfg.bpp		= 16;
+	priv->lcd3_cfg.fdd		= 0x80;
+	priv->lcd3_cfg.tft_alt_mode	= 0;
+	priv->lcd3_cfg.stn_565_mode	= 0;
+	priv->lcd3_cfg.mono_8bit_mode	= 0;
+	priv->lcd3_cfg.invert_line_clock= 1;
+	priv->lcd3_cfg.invert_frm_clock	= 1;
+	priv->lcd3_cfg.sync_edge	= 0;
+	priv->lcd3_cfg.sync_ctrl	= 1;
+	priv->lcd3_cfg.raster_order	= 0;
+
+	/* da8xx_lcdc_platform_data */
+	strcpy(priv->lcd3_pdata.manu_name, "BBToys");
+	priv->lcd3_pdata.controller_data = &priv->lcd3_cfg;
+	strcpy(priv->lcd3_pdata.type, "CDTech_S035Q01");
+
+	priv->lcdc_oh = omap_hwmod_lookup("lcdc");
+	if (priv->lcdc_oh == NULL) {
+		dev_err(&pdev->dev, "Failed to lookup omap_hwmod lcdc\n");
+		return -ENODEV;
+	}
+
+	priv->lcdc_pdev = omap_device_build("da8xx_lcdc", 0, priv->lcdc_oh,
+			&priv->lcd3_pdata,
+			sizeof(struct da8xx_lcdc_platform_data),
+			NULL, 0, 0);
+	if (priv->lcdc_pdev == NULL) {
+		dev_err(&pdev->dev, "Failed to build LCDC device\n");
+		return -ENODEV;
+	}
+
+	dev_info(&pdev->dev, "Registered bone LCD3 cape OK.\n");
+
+	platform_set_drvdata(pdev, priv);
+
+	return 0;
+}
+
+static int __devexit da8xx_dt_remove(struct platform_device *pdev)
+{
+	return -EINVAL;	/* not supporting removal yet */
+}
+
+static struct platform_driver da8xx_dt_driver = {
+	.probe		= da8xx_dt_probe,
+	.remove		= __devexit_p(da8xx_dt_remove),
+	.driver		= {
+		.name	= "da8xx-dt",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_da8xx_dt_match,
+	},
+};
+
+static atomic_t da8xx_dt_driver_used = ATOMIC_INIT(0);
+
+static int bonelcd3_probe(struct cape_dev *dev, const struct cape_device_id *id)
+{
+	static const struct of_device_id gpio_leds_of_match[] = {
+		{ .compatible = "gpio-leds", }, { },
+	};
+	static const struct of_device_id tps_bl_of_match[] = {
+		{ .compatible = "tps65217-backlight", }, { },
+	};
+	static const struct of_device_id gpio_keys_of_match[] = {
+		{ .compatible = "gpio-keys", }, { },
+	};
+	static const struct of_device_id da8xx_dt_of_match[] = {
+		{ .compatible = "da8xx-dt", }, { },
+	};
+	char boardbuf[33];
+	char versionbuf[5];
+	const char *board_name;
+	const char *version;
+	const struct of_device_id *match;
+	struct bone_lcd3_info *info;
+	struct pinctrl *pinctrl;
+	int err;
+
+	/* get the board name (also matches the cntrlboard before checking) */
+	board_name = bone_capebus_id_get_field(id, BONE_CAPEBUS_BOARD_NAME,
+			boardbuf, sizeof(boardbuf));
+	if (board_name == NULL)
+		return -ENODEV;
+
+	/* match compatible? */
+	match = capebus_of_match_device(dev, "board-name", board_name);
+	if (match == NULL)
+		return -ENODEV;
+
+	/* get the board version */
+	version = bone_capebus_id_get_field(id, BONE_CAPEBUS_VERSION,
+			versionbuf, sizeof(versionbuf));
+	if (version == NULL)
+		return -ENODEV;
+
+	pinctrl = devm_pinctrl_get_select_default(&dev->dev);
+	if (IS_ERR(pinctrl))
+		dev_warn(&dev->dev,
+			"pins are not configured from the driver\n");
+
+	smp_mb();
+	if (atomic_inc_return(&da8xx_dt_driver_used) == 1) {
+		smp_mb();
+		err = platform_driver_register(&da8xx_dt_driver);
+		if (err != 0) {
+			dev_err(&dev->dev, "Failed to register da8xx_dt "
+					"platform driver\n");
+			return -ENODEV;
+		}
+	}
+	smp_mb();
+
+	dev_info(&dev->dev, "%s: V=%s initialized - '%s'\n", board_name,
+			version, match->compatible);
+
+	dev->drv_priv = devm_kzalloc(&dev->dev, sizeof(*info), GFP_KERNEL);
+	if (dev->drv_priv == NULL) {
+		dev_err(&dev->dev, "Failed to allocate info\n");
+		err = -ENOMEM;
+		goto err_no_mem;
+	}
+	info = dev->drv_priv;
+
+	info->leds_pdev = capebus_of_platform_compatible_device_create(dev,
+			gpio_leds_of_match, "lcd3-cape-leds",
+			"version", version);
+	if (IS_ERR(info->leds_pdev)) {
+		info->leds_pdev = NULL;
+		dev_err(&dev->dev, "Failed to create platform led "
+				"platform device\n");
+		err = -ENODEV;
+		goto err_no_leds_pdev;
+	}
+
+	dev_info(&dev->dev, "LED pdev created OK\n");
+
+	info->tps_bl_pdev = capebus_of_platform_compatible_device_create(dev,
+			tps_bl_of_match, "lcd3-cape-bl",
+			"version", version);
+	if (IS_ERR(info->tps_bl_pdev)) {
+		info->tps_bl_pdev = NULL;
+		/* keep track; if we don't find any backlight device fail */
+	}
+
+	/* TODO: Add pwm backlight */
+
+	if (info->tps_bl_pdev == NULL && info->pwm_bl_pdev == NULL) {
+		dev_warn(&dev->dev, "Failed to backlight "
+				"platform device\n");
+		err = -ENODEV;
+		goto err_no_bl_pdev;
+	}
+
+	dev_info(&dev->dev, "Backlight pdev created OK\n");
+
+	info->keys_pdev = capebus_of_platform_compatible_device_create(dev,
+			gpio_keys_of_match, "lcd3-cape-keys",
+			"version", version);
+	if (IS_ERR(info->keys_pdev)) {
+		info->keys_pdev = NULL;
+		dev_err(&dev->dev, "Failed to create platform gpio-keys "
+				"platform device\n");
+		err = -ENODEV;
+		goto err_no_keys_pdev;
+	}
+
+	dev_info(&dev->dev, "GPIO keys pdev created OK\n");
+
+	info->tsc_data.wires = 8;
+	info->tsc_data.x_plate_resistance = 200;
+	info->tsc_data.steps_to_configure = 6;
+	info->adc_data.adc_channels = 0;
+	info->tscadc_data.tsc_init = &info->tsc_data;
+	info->tscadc_data.adc_init = &info->adc_data;
+
+	info->tsc_oh = omap_hwmod_lookup("adc_tsc");
+	if (info->tsc_oh == NULL) {
+		dev_err(&dev->dev, "Could not lookup HWMOD %s\n", "adc_tsc");
+		err = -ENODEV;
+		goto err_no_tsc_oh;
+	}
+	info->tscadc_pdev = omap_device_build("ti_tscadc", -1, info->tsc_oh,
+			&info->tscadc_data, sizeof(info->tscadc_data),
+			NULL, 0, 0);
+	if (info->tscadc_pdev == NULL) {
+		dev_err(&dev->dev, "Could not create tsc_adc device\n");
+		err = -ENODEV;
+		goto err_no_tsc_pdev;
+	}
+
+	dev_info(&dev->dev, "TI tscadc pdev created OK\n");
+
+	info->da8xx_pdev = capebus_of_platform_compatible_device_create(dev,
+			da8xx_dt_of_match, "lcd3-cape-da8xx",
+			"version", version);
+	if (IS_ERR(info->da8xx_pdev)) {
+		info->da8xx_pdev = NULL;
+		dev_err(&dev->dev, "Failed to create da8xx platform device\n");
+		err = -ENODEV;
+		goto err_no_da8xx_fb;
+	}
+
+	dev_info(&dev->dev, "da8xx-dt pdev created OK\n");
+
+	return 0;
+
+err_no_da8xx_fb:
+	platform_device_unregister(info->tscadc_pdev);
+err_no_tsc_pdev:
+	/* nothing */
+err_no_tsc_oh:
+	platform_device_unregister(info->keys_pdev);
+err_no_keys_pdev:
+	platform_device_unregister(info->tps_bl_pdev);
+err_no_bl_pdev:
+	platform_device_unregister(info->leds_pdev);
+err_no_leds_pdev:
+	devm_kfree(&dev->dev, info);
+err_no_mem:
+	smp_mb();
+	if (atomic_dec_return(&da8xx_dt_driver_used) == 0) {
+		smp_mb();
+		platform_driver_unregister(&da8xx_dt_driver);
+	}
+	smp_mb();
+	return err;
+}
+
+static void bonelcd3_remove(struct cape_dev *dev)
+{
+	dev_info(&dev->dev, "%s\n", __func__);
+}
+
+struct cape_driver bonelcd3_driver = {
+	.driver = {
+		.name		= "bonelcd3",
+		.owner		= THIS_MODULE,
+		.of_match_table	= bonelcd3_of_match,
+	},
+	.probe		= bonelcd3_probe,
+	.remove		= bonelcd3_remove,
+};
+
+module_capebus_driver(bonelcd3_driver);
+
+MODULE_AUTHOR("Pantelis Antoniou");
+MODULE_DESCRIPTION("Beaglebone LCD3 cape");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:bone-lcd3-cape");
-- 
1.7.7.6

