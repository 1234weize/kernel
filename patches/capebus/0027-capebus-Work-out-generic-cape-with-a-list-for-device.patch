From ef3cb8e878e9c2c2c237ab4eb5b3a2bde581609b Mon Sep 17 00:00:00 2001
From: Pantelis Antoniou <panto@antoniou-consulting.com>
Date: Sat, 20 Oct 2012 11:07:56 +0300
Subject: [PATCH 27/33] capebus: Work out generic cape with a list for
 devices...

---
 arch/arm/boot/dts/am335x-bone.dts           |    1 +
 drivers/capebus/boards/capebus-bone-pdevs.c |  167 ++++++++++++++++-----------
 drivers/capebus/capes/bone-geiger-cape.c    |   21 ++--
 drivers/capebus/capes/bone-generic-cape.c   |    5 +
 include/linux/capebus/capebus-bone.h        |   23 +++-
 5 files changed, 136 insertions(+), 81 deletions(-)

diff --git a/arch/arm/boot/dts/am335x-bone.dts b/arch/arm/boot/dts/am335x-bone.dts
index 80dd048..0d3a4fb 100644
--- a/arch/arm/boot/dts/am335x-bone.dts
+++ b/arch/arm/boot/dts/am335x-bone.dts
@@ -444,6 +444,7 @@
 &bone_geiger_cape {
 	board-name = "Geiger Cape";
 
+	/* note that these can't be versioned... */
 	pinctrl-names = "default";
 	pinctrl-0 = <&bone_geiger_cape_pins>;
 
diff --git a/drivers/capebus/boards/capebus-bone-pdevs.c b/drivers/capebus/boards/capebus-bone-pdevs.c
index d274353..3ee8601 100644
--- a/drivers/capebus/boards/capebus-bone-pdevs.c
+++ b/drivers/capebus/boards/capebus-bone-pdevs.c
@@ -385,26 +385,9 @@ void bone_capebus_unregister_pdev_adapters(struct bone_capebus_bus *bus)
 	}
 }
 
-struct bone_capebus_generic_info *
-bone_capebus_probe_generic(struct cape_dev *dev,
+int bone_capebus_probe_prolog(struct cape_dev *dev,
 		const struct cape_device_id *id)
 {
-	static const struct of_device_id gpio_leds_of_match[] = {
-		{ .compatible = "gpio-leds", }, { },
-	};
-	static const struct of_device_id tps_bl_of_match[] = {
-		{ .compatible = "tps65217-backlight", }, { },
-	};
-	static const struct of_device_id gpio_keys_of_match[] = {
-		{ .compatible = "gpio-keys", }, { },
-	};
-	static const struct of_device_id ti_tscadc_dt_of_match[] = {
-		{ .compatible = "ti-tscadc-dt", }, { },
-	};
-	static const struct of_device_id da8xx_dt_of_match[] = {
-		{ .compatible = "da8xx-dt", }, { },
-	};
-	struct bone_capebus_generic_info *info;
 	char boardbuf[33];
 	char versionbuf[5];
 	const char *board_name;
@@ -416,18 +399,18 @@ bone_capebus_probe_generic(struct cape_dev *dev,
 	board_name = bone_capebus_id_get_field(id, BONE_CAPEBUS_BOARD_NAME,
 			boardbuf, sizeof(boardbuf));
 	if (board_name == NULL)
-		return ERR_PTR(ENODEV);
+		return -ENODEV;
 
 	/* match compatible? */
 	match = capebus_of_match_device(dev, "board-name", board_name);
 	if (match == NULL)
-		return ERR_PTR(ENODEV);
+		return -ENODEV;
 
 	/* get the board version */
 	version = bone_capebus_id_get_field(id, BONE_CAPEBUS_VERSION,
 			versionbuf, sizeof(versionbuf));
 	if (version == NULL)
-		return ERR_PTR(-ENODEV);
+		return -ENODEV;
 
 	pinctrl = devm_pinctrl_get_select_default(&dev->dev);
 	if (IS_ERR(pinctrl))
@@ -437,53 +420,100 @@ bone_capebus_probe_generic(struct cape_dev *dev,
 	dev_info(&dev->dev, "%s: V=%s '%s'\n", board_name,
 			version, match->compatible);
 
+	return 0;
+}
+EXPORT_SYMBOL(bone_capebus_probe_prolog);
+
+static const struct bone_capebus_generic_device_data gendevs[] = {
+	{
+		.name	= "leds",
+		.of_match = (const struct of_device_id []) {
+				{ .compatible = "gpio-leds", }, { },
+			},
+		.units	 = 0,	/* no limit */
+	}, {
+		.name	= "tps-bl",
+		.of_match = (const struct of_device_id []) {
+				{ .compatible = "tps65217-backlight", }, { },
+			},
+		.units	 = 0,	/* no limit */
+	}, {
+		.name	= "keys",
+		.of_match = (const struct of_device_id []) {
+				{ .compatible = "gpio-keys", }, { },
+			},
+		.units	 = 0,	/* no limit */
+	}, {
+		.name	= "tscadc",
+		.of_match = (const struct of_device_id []) {
+				{ .compatible = "ti-tscadc-dt", }, { },
+			},
+		.units	 = 1,
+	}, {
+		.name	= "lcdc",
+		.of_match = (const struct of_device_id []) {
+				{ .compatible = "da8xx-dt", }, { },
+			},
+		.units	 = 1,
+	},
+};
+
+struct bone_capebus_generic_info *
+bone_capebus_probe_generic(struct cape_dev *dev,
+		const struct cape_device_id *id)
+{
+	struct bone_capebus_generic_info *info;
+	char boardbuf[33];
+	char versionbuf[5];
+	const char *board_name;
+	const char *version;
+	struct platform_device *pdev;
+	const struct bone_capebus_generic_device_data *dd;
+	struct bone_capebus_generic_device_entry *de;
+	int i;
+
+	/* get the board name (also matches the cntrlboard before checking) */
+	board_name = bone_capebus_id_get_field(id, BONE_CAPEBUS_BOARD_NAME,
+			boardbuf, sizeof(boardbuf));
+	/* get the board version */
+	version = bone_capebus_id_get_field(id, BONE_CAPEBUS_VERSION,
+			versionbuf, sizeof(versionbuf));
+
+	/* should never happen, but it doesn't hurt to play it safe */
+	if (board_name == NULL || version == NULL)
+		return ERR_PTR(-ENODEV);
+
 	info = devm_kzalloc(&dev->dev, sizeof(*info), GFP_KERNEL);
 	if (info == NULL) {
 		dev_err(&dev->dev, "Failed to allocate info\n");
 		return ERR_PTR(-ENOMEM);
 	}
 	info->dev = dev;
+	INIT_LIST_HEAD(&info->pdev_list);
+
+	/* iterate over the supported devices */
+	for (i = 0, dd = gendevs; i < ARRAY_SIZE(gendevs); i++, dd++) {
+		pdev = capebus_of_platform_compatible_device_create(dev,
+			dd->of_match, dd->name, "version", version);
+		if (IS_ERR(pdev))
+			pdev = NULL;
+
+		if (pdev == NULL)
+			continue;
 
-	/* NOTE: platform devices fail to be created silently */
-	info->leds_pdev = capebus_of_platform_compatible_device_create(dev,
-			gpio_leds_of_match, "generic-cape-leds",
-			"version", version);
-	if (IS_ERR(info->leds_pdev))
-		info->leds_pdev = NULL;
-	if (info->leds_pdev != NULL)
-		dev_info(&dev->dev, "LED pdev created OK\n");
-
-	info->tps_bl_pdev = capebus_of_platform_compatible_device_create(
-			dev, tps_bl_of_match, "generic-cape-bl",
-			"version", version);
-	if (IS_ERR(info->tps_bl_pdev))
-		info->tps_bl_pdev = NULL;
-	if (info->tps_bl_pdev != NULL)
-		dev_info(&dev->dev, "tps backlight pdev created OK\n");
-
-	info->keys_pdev = capebus_of_platform_compatible_device_create(dev,
-			gpio_keys_of_match, "generic-cape-keys",
-			"version", version);
-	if (IS_ERR(info->keys_pdev))
-		info->keys_pdev = NULL;
-	if (info->keys_pdev != NULL)
-		dev_info(&dev->dev, "GPIO keys pdev created OK\n");
-
-	info->tscadc_dt_pdev = capebus_of_platform_compatible_device_create(dev,
-			ti_tscadc_dt_of_match, "generic-cape-ti-tscadc",
-			"version", version);
-	if (IS_ERR(info->tscadc_dt_pdev))
-		info->tscadc_dt_pdev = NULL;
-	if (info->tscadc_dt_pdev != NULL)
-		dev_info(&dev->dev, "TI tscadc pdev created OK\n");
-
-	info->da8xx_dt_pdev = capebus_of_platform_compatible_device_create(dev,
-			da8xx_dt_of_match, "generic-cape-da8xx",
-			"version", version);
-	if (IS_ERR(info->da8xx_dt_pdev))
-		info->da8xx_dt_pdev = NULL;
-	if (info->da8xx_dt_pdev != NULL)
-		dev_info(&dev->dev, "da8xx-dt pdev created OK\n");
+		de = devm_kzalloc(&dev->dev, sizeof(*de), GFP_KERNEL);
+		if (de == NULL) {
+			dev_err(&dev->dev, "failed to allocate entry for %s\n",
+					dd->name);
+			platform_device_unregister(pdev);
+			continue;
+		}
+
+		/* add it to the list */
+		de->data = dd;
+		de->pdev = pdev;
+		list_add_tail(&de->node, &info->pdev_list);
+	}
 
 	return info;
 }
@@ -491,11 +521,16 @@ EXPORT_SYMBOL(bone_capebus_probe_generic);
 
 void bone_capebus_remove_generic(struct bone_capebus_generic_info *info)
 {
-	platform_device_unregister(info->da8xx_dt_pdev);
-	platform_device_unregister(info->tscadc_dt_pdev);
-	platform_device_unregister(info->keys_pdev);
-	platform_device_unregister(info->tps_bl_pdev);
-	platform_device_unregister(info->leds_pdev);
+	struct list_head *lh, *lhn;
+	struct bone_capebus_generic_device_entry *de;
+
+	list_for_each_safe(lh, lhn, &info->pdev_list) {
+		de = list_entry(lh, struct bone_capebus_generic_device_entry,
+				node);
+		list_del(lh);
+		platform_device_unregister(de->pdev);
+		devm_kfree(&info->dev->dev, de);
+	}
 	devm_kfree(&info->dev->dev, info);
 }
 EXPORT_SYMBOL(bone_capebus_remove_generic);
diff --git a/drivers/capebus/capes/bone-geiger-cape.c b/drivers/capebus/capes/bone-geiger-cape.c
index b3fb979..73b9c33 100644
--- a/drivers/capebus/capes/bone-geiger-cape.c
+++ b/drivers/capebus/capes/bone-geiger-cape.c
@@ -45,6 +45,8 @@ extern struct cape_driver bonegeiger_driver;
 struct bone_geiger_info {
 	struct cape_dev *dev;
 	struct platform_device *leds_pdev;
+	struct platform_device *tscadc_pdev;
+
 	struct pwm_device *pwm_dev;
 	int pwm_frequency;
 	int pwm_duty_cycle;
@@ -56,7 +58,6 @@ struct bone_geiger_info {
 	struct led_trigger *run_led;		/* running      */
 	unsigned long event_blink_delay;
 	struct sysfs_dirent *counter_sd;	/* notifier */
-	struct platform_device *tscadc_pdev;
 	const char *vsense_name;
 	unsigned int vsense_scale;
 	struct iio_channel *vsense_channel;
@@ -392,6 +393,15 @@ static int bonegeiger_probe(struct cape_dev *dev, const struct cape_device_id *i
 	led_trigger_register_simple("geiger-event", &info->event_led);
 	led_trigger_register_simple("geiger-run", &info->run_led);
 
+	info->tscadc_pdev = capebus_of_platform_compatible_device_create(dev,
+			ti_tscadc_dt_of_match, "geiger-cape-ti-tscadc",
+			"version", version);
+	if (info->tscadc_pdev == NULL) {
+		dev_err(&dev->dev, "Could not create tsc_adc device\n");
+		err = -ENODEV;
+		goto err_no_tsc_pdev;
+	}
+
 	/* must be last, for the led-trigger to be picked up */
 	info->leds_pdev = capebus_of_platform_compatible_device_create(dev,
 			gpio_leds_of_match, "geiger-cape-leds",
@@ -417,15 +427,6 @@ static int bonegeiger_probe(struct cape_dev *dev, const struct cape_device_id *i
 	}
 	info->event_blink_delay = val;
 
-	info->tscadc_pdev = capebus_of_platform_compatible_device_create(dev,
-			ti_tscadc_dt_of_match, "geiger-cape-ti-tscadc",
-			"version", version);
-	if (info->tscadc_pdev == NULL) {
-		dev_err(&dev->dev, "Could not create tsc_adc device\n");
-		err = -ENODEV;
-		goto err_no_tsc_pdev;
-	}
-
 	/* default */
 	if (capebus_of_property_read_string(dev,
 				"version", version,
diff --git a/drivers/capebus/capes/bone-generic-cape.c b/drivers/capebus/capes/bone-generic-cape.c
index 55feda0..7c74b9a 100644
--- a/drivers/capebus/capes/bone-generic-cape.c
+++ b/drivers/capebus/capes/bone-generic-cape.c
@@ -60,6 +60,11 @@ static int bonegeneric_probe(struct cape_dev *dev,
 		const struct cape_device_id *id)
 {
 	struct bone_capebus_generic_info *ginfo;
+	int err;
+
+	err = bone_capebus_probe_prolog(dev, id);
+	if (err != 0)
+		return err;
 
 	ginfo = bone_capebus_probe_generic(dev, id);
 	if (IS_ERR_OR_NULL(ginfo))
diff --git a/include/linux/capebus/capebus-bone.h b/include/linux/capebus/capebus-bone.h
index 0791905..e394304 100644
--- a/include/linux/capebus/capebus-bone.h
+++ b/include/linux/capebus/capebus-bone.h
@@ -23,6 +23,7 @@
 #ifndef LINUX_CAPEBUS_BONE_H
 #define LINUX_CAPEBUS_BONE_H
 
+#include <linux/list.h>
 #include <linux/capebus.h>
 
 struct bone_capebus_slot {
@@ -88,15 +89,27 @@ int bone_capebus_register_pdev_adapters(struct bone_capebus_bus *bus);
 void bone_capebus_unregister_pdev_adapters(struct bone_capebus_bus *bus);
 
 /* generic cape support */
+
+struct bone_capebus_generic_device_data {
+	const char *name;
+	const struct of_device_id *of_match;
+	unsigned int units;
+};
+
+struct bone_capebus_generic_device_entry {
+	struct list_head node;
+	const struct bone_capebus_generic_device_data *data;
+	struct platform_device *pdev;
+};
+
 struct bone_capebus_generic_info {
 	struct cape_dev *dev;
-	struct platform_device *leds_pdev;
-	struct platform_device *da8xx_dt_pdev;
-	struct platform_device *tps_bl_pdev;
-	struct platform_device *keys_pdev;
-	struct platform_device *tscadc_dt_pdev;
+	struct list_head pdev_list;
 };
 
+int bone_capebus_probe_prolog(struct cape_dev *dev,
+		const struct cape_device_id *id);
+
 struct bone_capebus_generic_info *
 bone_capebus_probe_generic(struct cape_dev *dev,
 		const struct cape_device_id *id);
-- 
1.7.7.6

