From 3b9cfae52c1b7f3b5980fe064f958daf47cc0a19 Mon Sep 17 00:00:00 2001
From: Pantelis Antoniou <panto@antoniou-consulting.com>
Date: Fri, 26 Oct 2012 16:53:13 +0300
Subject: [PATCH 52/52] capebus: Auto-enabling of disabled devices.

---
 drivers/capebus/boards/capebus-bone-pdevs.c |   18 +++++++
 drivers/capebus/capebus-driver.c            |   67 +++++++++++++++++++++++++++
 drivers/capebus/capes/bone-geiger-cape.c    |   30 ++++++++++++-
 include/linux/capebus.h                     |    3 +
 4 files changed, 117 insertions(+), 1 deletions(-)

diff --git a/drivers/capebus/boards/capebus-bone-pdevs.c b/drivers/capebus/boards/capebus-bone-pdevs.c
index c144905..c026179 100644
--- a/drivers/capebus/boards/capebus-bone-pdevs.c
+++ b/drivers/capebus/boards/capebus-bone-pdevs.c
@@ -349,6 +349,13 @@ static int __devinit i2c_dt_probe(struct platform_device *pdev)
 		goto err_node_fail;
 	}
 
+	ret = capebus_of_platform_device_enable(adap_node);
+	if (ret != 0) {
+		dev_info(&pdev->dev, "I2C adapter platform device failed "
+				"to enable\n");
+		goto err_enable_fail;
+	}
+
 	priv->i2c_adapter = of_find_i2c_adapter_by_node(adap_node);
 	if (priv->i2c_adapter == NULL) {
 		dev_err(&pdev->dev, "Failed to find i2c adapter node\n");
@@ -367,6 +374,8 @@ static int __devinit i2c_dt_probe(struct platform_device *pdev)
 	return 0;
 err_adap_fail:
 	of_node_put(adap_node);
+err_enable_fail:
+	/* nothing */
 err_node_fail:
 	/* nothing */
 err_prop_fail:
@@ -426,6 +435,7 @@ static int __devinit spi_dt_probe(struct platform_device *pdev)
 	struct spi_priv *priv = NULL;
 	int ret = -EINVAL;
 	struct device_node *master_node;
+	struct platform_device *master_pdev, *parent_pdev;
 	u32 val;
 
 	if (pdev->dev.of_node == NULL) {
@@ -453,6 +463,12 @@ static int __devinit spi_dt_probe(struct platform_device *pdev)
 		goto err_node_fail;
 	}
 
+	ret = capebus_of_platform_device_enable(master_node);
+	if (ret != 0) {
+		dev_info(&pdev->dev, "SPI platform device failed to enable\n");
+		goto err_enable_fail;
+	}
+
 	priv->master = of_find_spi_master_by_node(master_node);
 	if (priv->master == NULL) {
 		dev_err(&pdev->dev, "Failed to find bus master node\n");
@@ -471,6 +487,8 @@ static int __devinit spi_dt_probe(struct platform_device *pdev)
 	return 0;
 err_master_fail:
 	of_node_put(master_node);
+err_enable_fail:
+	/* nothing */
 err_node_fail:
 	/* nothing */
 err_prop_fail:
diff --git a/drivers/capebus/capebus-driver.c b/drivers/capebus/capebus-driver.c
index 9718c99..69c45c0 100644
--- a/drivers/capebus/capebus-driver.c
+++ b/drivers/capebus/capebus-driver.c
@@ -559,3 +559,70 @@ const void *capebus_of_get_property(struct cape_dev *dev,
 	return pp ? pp->value : NULL;
 }
 EXPORT_SYMBOL_GPL(capebus_of_get_property);
+
+/* node exists, but it's not available? make it so */
+int capebus_of_device_node_enable(struct device_node *node)
+{
+	struct property *prop;
+	int ret;
+
+	prop = kzalloc(sizeof(*prop), GFP_KERNEL);
+	if (prop == NULL)
+		goto err_no_prop_mem;
+
+	prop->name = kstrdup("status", GFP_KERNEL);
+	if (prop->name == NULL)
+		goto err_no_name_mem;
+
+	prop->value = kstrdup("okay", GFP_KERNEL);
+	if (prop->value == NULL)
+		goto err_no_value_mem;
+
+	prop->length = strlen(prop->value) + 1;
+	set_bit(OF_DYNAMIC, &prop->_flags);
+
+	ret = prom_update_property(node, prop);
+	if (ret != 0)
+		goto err_update_failed;
+
+	return 0;
+
+err_update_failed:
+	kfree(prop->value);
+err_no_value_mem:
+	kfree(prop->name);
+err_no_name_mem:
+	kfree(prop);
+err_no_prop_mem:
+	return -ENOMEM;
+}
+EXPORT_SYMBOL_GPL(capebus_of_device_node_enable);
+
+/* Make sure this node is activated (even if it was disabled) */
+int capebus_of_platform_device_enable(struct device_node *node)
+{
+	struct platform_device *pdev, *ppdev;
+	int ret;
+
+	if (of_device_is_available(node))
+		return 0;
+
+	ret = capebus_of_device_node_enable(node);
+	if (ret != 0)
+		return ret;
+
+	/* now we need to find the parent of the node */
+	ppdev = of_find_device_by_node(node->parent);
+
+	pdev = of_platform_device_create(node, NULL,
+			ppdev ? &ppdev->dev : NULL);
+	if (IS_ERR_OR_NULL(pdev)) {
+		ret = pdev ? PTR_ERR(pdev) : -ENODEV;
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(capebus_of_platform_device_enable);
+
+
diff --git a/drivers/capebus/capes/bone-geiger-cape.c b/drivers/capebus/capes/bone-geiger-cape.c
index 8d64e2d..948ce8f 100644
--- a/drivers/capebus/capes/bone-geiger-cape.c
+++ b/drivers/capebus/capes/bone-geiger-cape.c
@@ -253,7 +253,8 @@ static int bonegeiger_probe(struct cape_dev *dev, const struct cape_device_id *i
 	const struct of_device_id *match;
 	struct bone_geiger_info *info;
 	struct pinctrl *pinctrl;
-	struct device_node *node;
+	struct device_node *node, *pwm_node;
+	phandle phandle;
 	u32 val;
 	int err;
 
@@ -295,6 +296,33 @@ static int bonegeiger_probe(struct cape_dev *dev, const struct cape_device_id *i
 	dev_info(&dev->dev, "Getting PWM device\n");
 
 	node = capebus_of_find_property_node(dev, "version", version, "pwms");
+	if (node == NULL) {
+		dev_err(&dev->dev, "unable to find pwms property\n");
+		err = -ENODEV;
+		goto err_no_pwm;
+	}
+
+	err = of_property_read_u32(node, "pwms", &val);
+	if (err != 0) {
+		dev_err(&dev->dev, "unable to read pwm handle\n");
+		goto err_no_pwm;
+	}
+	phandle = val;
+
+	pwm_node = of_find_node_by_phandle(phandle);
+	if (pwm_node == NULL) {
+		dev_err(&dev->dev, "Failed to pwm node\n");
+		err = -EINVAL;
+		goto err_no_pwm;
+	}
+
+	err = capebus_of_platform_device_enable(pwm_node);
+	of_node_put(pwm_node);
+	if (err != 0) {
+		dev_err(&dev->dev, "Failed to pwm node\n");
+		goto err_no_pwm;
+	}
+
 	info->pwm_dev = of_pwm_request(node, NULL);
 	of_node_put(node);
 	if (IS_ERR(info->pwm_dev)) {
diff --git a/include/linux/capebus.h b/include/linux/capebus.h
index e063325..8213e56 100644
--- a/include/linux/capebus.h
+++ b/include/linux/capebus.h
@@ -291,4 +291,7 @@ static inline int capebus_of_property_read_u64(struct cape_dev *dev,
 	return ret;
 }
 
+int capebus_of_device_node_enable(struct device_node *node);
+int capebus_of_platform_device_enable(struct device_node *node);
+
 #endif
-- 
1.7.7.6

